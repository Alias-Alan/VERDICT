package com.ge.research.osate.verdict.handlers;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.IWorkbenchWindow;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.handlers.HandlerUtil;
import org.eclipse.ui.intro.IIntroPart;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.osate.aadl2.ConnectedElement;
import org.osate.aadl2.Connection;
import org.osate.aadl2.ConnectionEnd;
import org.osate.aadl2.Element;
import org.osate.aadl2.PublicPackageSection;
import org.osate.aadl2.SystemImplementation;
import org.osate.aadl2.SystemType;

import com.ge.research.osate.verdict.alloy.AadlAlloyTranslator;
import com.ge.research.osate.verdict.alloy.Util;
import com.ge.research.osate.verdict.gui.BundlePreferences;
import com.ge.research.osate.verdict.gui.MBASReportGenerator;

/**
*
* Author: Paul Meng
* Date: Jun 12, 2019
*
*/

public class MBASHandler extends AbstractHandler {
	static final String SEP = File.separator;

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		if (VerdictHandlersUtils.startRun()) {
			// Print on console
			IIntroPart introPart = PlatformUI.getWorkbench().getIntroManager().getIntro();
			PlatformUI.getWorkbench().getIntroManager().closeIntro(introPart);
			final IWorkbenchWindow iWindow = HandlerUtil.getActiveWorkbenchWindow(event);
			VerdictHandlersUtils.setPrintOnConsole("MBAS Output");
			Display mainThreadDisplay = Display.getCurrent();

			Thread mbasAnalysisThread = new Thread() {
				@Override
				public void run() {
					test(VerdictHandlersUtils.getCurrentSelection(event));
//					try {
//						
//						String bundleJar = BundlePreferences.getBundleJar();
//						if (bundleJar.length() == 0) {
//							System.out.println("Please set Verdict Bundle Jar path in Preferences");
//							return;
//						}
//						String aadl2imlBin = BundlePreferences.getAadl2imlBin();
//						if (aadl2imlBin.length() == 0) {
//							System.out.println("Please set aadl2iml binary path in Preferences");
//							return;
//						}
//						String stemProjPath = BundlePreferences.getStemDir();
//						if (stemProjPath.length() == 0) {
//							System.out.println("Please set STEM directory path in Preferences");
//							return;
//						}
//						String soteriaPpBin = BundlePreferences.getSoteriaPpBin();
//						if (soteriaPpBin.length() == 0) {
//							System.out.println("Please set soteria++ binary path in Preferences");
//							return;
//						}
//						String graphVizPath = BundlePreferences.getGraphVizPath();
//						if (graphVizPath.length() == 0) {
//							System.out.println("Please set GraphViz path in Preferences");
//							return;
//						}
//
//						VerdictHandlersUtils.printGreeting();
//						List<String> selection = VerdictHandlersUtils.getCurrentSelection(event);
//
//						// Create CSVData, Output, Graphs folders if they don't exist
//						// If they exist, delete all the csv and svg files
//						File CSVDataFolder = new File(stemProjPath, "CSVData");
//						File outputFolder = new File(stemProjPath, "Output");
//						File graphsFolder = new File(stemProjPath, "Graphs");
//
//						if (CSVDataFolder.exists() && CSVDataFolder.isDirectory()) {
//							deleteCsvFilesInDir(CSVDataFolder);
//						} else {
//							CSVDataFolder.mkdir();
//						}
//						if (outputFolder.exists() && outputFolder.isDirectory()) {
//							deleteCsvFilesInDir(outputFolder);
//						} else {
//							outputFolder.mkdir();
//						}
//						if (graphsFolder.exists() && graphsFolder.isDirectory()) {
//							deleteSvgFilesInDir(graphsFolder);
//						} else {
//							graphsFolder.mkdir();
//						}
//
//						if (runBundle(bundleJar, selection.get(0), aadl2imlBin, stemProjPath, soteriaPpBin,
//								graphVizPath)) {
//							// Soteria++ output directory
//							String soteriaOut = stemProjPath + SEP + "Output" + SEP + "Soteria_Output";
//
//							// Open SVG file generated by STEM
//							VerdictHandlersUtils
//									.openSvgGraphsInDir(new File(stemProjPath, "Graphs").getAbsolutePath());
//							// Run this code on the UI thread
//							mainThreadDisplay.asyncExec(() -> {
//
//								File applicableDefense = new File(soteriaOut, "ApplicableDefenseProperties.xml");
//								File implProperty = new File(soteriaOut, "ImplProperties.xml");
//								File safetyApplicableDefense = new File(soteriaOut, "ApplicableDefenseProperties-safety.xml");
//								File safetyImplProperty = new File(soteriaOut, "ImplProperties-safety.xml");
//								
//								File stemOut = new File(stemProjPath, "Output");
//								File capecFile = new File(stemOut, "CAPEC.csv");
//								File nistFile = new File(stemOut, "Defenses2NIST.csv");
//
//								// Display cyber related xml
//								if (applicableDefense.exists() && implProperty.exists()) {
//									new MBASReportGenerator(applicableDefense.getAbsolutePath(),
//											implProperty.getAbsolutePath(), safetyApplicableDefense.getAbsolutePath(),
//											safetyImplProperty.getAbsolutePath(), iWindow,
//											capecFile.getAbsolutePath(), nistFile.getAbsolutePath());
//								} else {
//									System.err.println("Info: No Soteria++ output generated!");
//								}
//							});
							// Display safety related text.
//							VerdictHandlersUtils.openSafetyTxtInDir(soteriaOut);
//						}
//					} finally {
//						VerdictHandlersUtils.finishRun();
//					}
				}
			};
			mbasAnalysisThread.start();
		}
		return null;
	}
	
	public static void test(List<String> selection) {
		File dir = new File(selection.get(0));
		XtextResourceSet resourceSet = new XtextResourceSet();
		// Get all AADL files in the project
		List<EObject> objects = new ArrayList<>();
		for (File file : dir.listFiles()) {
			if (file.getAbsolutePath().endsWith(".aadl")) {
				Resource resource = resourceSet.getResource(URI.createFileURI(file.getAbsolutePath()), true);
				objects.addAll(resource.getContents());
			}
		}
		
		translateFromAADLObjects(objects);
	}
	
	public static void translateFromAADLObjects(Collection<EObject> objects) {
		List<PublicPackageSection> models = objects.stream()
				.map(MBASHandler::getModel)
				.flatMap(Util::streamOfOptional)
				.collect(Collectors.toList());
		
		List<SystemType> systems = new ArrayList<>();
		List<SystemImplementation> systemImpls = new ArrayList<>();
		
		// Collect component type and implementation 
		for (PublicPackageSection model : models) {
			TreeIterator<EObject> it = model.eAllContents();
			while (it.hasNext()) {
				EObject obj = it.next();
				if (obj instanceof SystemType) {
					systems.add((SystemType) obj);
					it.prune();
				} else if (obj instanceof SystemImplementation) {
					systemImpls.add((SystemImplementation) obj);
					it.prune();
				}
			}
		}
		
		
		for (SystemImplementation systemImpl : systemImpls) {
			translateSystemImpl(systemImpl);
		}
	}	
	
	protected static void translateSystemImpl(SystemImplementation systemImpl) {
		for(Connection conn : systemImpl.getOwnedConnections()) {
			System.out.println("############## Connection Full Name: " + conn.getFullName() + " ##############");

			
			System.out.println("------ Src Connection End");
			ConnectionEnd srcConnectionEnd = conn.getAllSource();
			
			if(srcConnectionEnd.getContainingComponentImpl() != null) {
				System.out.println("srcConnectionEnd.getContainingComponentImpl().getFullName() = " + srcConnectionEnd.getContainingComponentImpl().getFullName());
			} else {
				System.out.println("srcConnectionEnd.getContainingComponentImpl().getFullName() = " + null);
			}
			System.out.println("srcConnectionEnd.getContainingClassifier().getFullName() = " + srcConnectionEnd.getContainingClassifier().getFullName());
			System.out.println("srcConnectionEnd.getFullName() = " + srcConnectionEnd.getFullName());
			System.out.println("srcConnectionEnd.getQualifiedName() = " + srcConnectionEnd.getQualifiedName());
			System.out.println("srcConnectionEnd.getName() = " + srcConnectionEnd.getName());
			
			System.out.println("------ Dest Connection End");
			
			ConnectionEnd destConnectionEnd = conn.getAllDestination();
			
			if(conn.getAllDestinationContext() == null) {
				System.out.println("conn.getAllDestinationContext().getFullName() = " + null);
			} else {
				System.out.println("conn.getAllDestinationContext().getFullName() = " + conn.getAllDestinationContext().getFullName());	
			}
			
			for(Element element : destConnectionEnd.getOwnedElements()) {
				System.out.println("destConnectionEnd.getOwnedElements() = " + element.toString());
			}
			if(destConnectionEnd.getContainingComponentImpl() != null) {
				System.out.println("destConnectionEnd.getContainingComponentImpl().getFullName() = " + destConnectionEnd.getContainingComponentImpl().getFullName());
			} else {
				System.out.println("destConnectionEnd.getContainingComponentImpl().getFullName() = " + null);
			}
			System.out.println("destConnectionEnd.getElementRoot().getFullName() = " + destConnectionEnd.getElementRoot().getFullName());
			System.out.println("destConnectionEnd.getContainingClassifier().getFullName() = " + destConnectionEnd.getContainingClassifier().getFullName());
			System.out.println("destConnectionEnd.getFullName() = " + destConnectionEnd.getFullName());
			System.out.println("destConnectionEnd.getQualifiedName() = " + destConnectionEnd.getQualifiedName());
			System.out.println("destConnectionEnd.getName() = " + destConnectionEnd.getName());
			

		}
	}
	
	protected static Optional<PublicPackageSection> getModel(EObject obj) {
		return Util.searchEObject(obj, PublicPackageSection.class);
	}	

	public static boolean runBundle(String bundleJar, String inputPath, String aadl2imlBin, String stemProjectDir,
			String soteriaPpBin, String graphVizPath) {
		List<String> args = new ArrayList<>();

		args.add(VerdictHandlersUtils.JAVA);
		args.add(VerdictHandlersUtils.JAR);
		args.add(bundleJar);

		args.add("--aadl");
		args.add(inputPath);
		args.add(aadl2imlBin);

		args.add("--mbas");
		args.add(stemProjectDir);
		args.add(soteriaPpBin);

		String[] env = { "GraphVizPath=" + graphVizPath };

		int code = VerdictHandlersUtils.run(args.toArray(new String[args.size()]), null, env);

		return code == 0;
	}

	/**
	 * Delete all csv files in a folder
	 * */
	static void deleteCsvFilesInDir(File dir) {
		if (dir.exists()) {
			if (dir.isDirectory()) {
				for (File file : dir.listFiles()) {
					if (file.isFile()) {
						if (getFileExtension(file).equals("csv")) {
							file.delete();
						}
					}
				}
			} else {
				dir.mkdirs();
			}
		} else {
			dir.mkdirs();
		}
	}

	/**
	 * Delete all svg files in a folder
	 * */
	static void deleteSvgFilesInDir(File dir) {
		if (dir.exists()) {
			if (dir.isDirectory()) {
				for (File file : dir.listFiles()) {
					if (file.isFile()) {
						if (getFileExtension(file).equals("svg")) {
							file.delete();
						}
					}
				}
			} else {
				dir.mkdirs();
			}
		} else {
			dir.mkdirs();
		}
	}

	/**
	 * Get the extension of a file
	 * */
	private static String getFileExtension(File file) {
		String extension = "";

		try {
			if (file != null && file.exists()) {
				String name = file.getName();
				extension = name.substring(name.lastIndexOf(".") + 1).toLowerCase();
			}
		} catch (Exception e) {
			extension = "";
		}

		return extension;

	}

}
